    [] op.type = "move_shard" →
        LET old_shards = shardMap[op.node]
            descendants = Descendants(op.node)  \* Get full subtree
            original_parent = CHOOSE p ∈ DOMAIN sceneState : 
                                 sceneState[p].left_child = op.node ∨ 
                                 sceneState[p].right_sibling = op.node
        IN ∧ ∀ n ∈ descendants :
                ∧ LeaderAppend(op.new_shard, [type: "state_transfer", node: n, 
                                           state: sceneState[n], hlc: HLC])
                ∧ shardMap' = [shardMap EXCEPT ![n] = {op.new_shard}]
                ∧ ∀ s ∈ old_shards : 
                    LeaderAppend(s, [type: "shard_remove", node: n])
        \* Detach from original parent (cross-shard operation)
        ∧ IF original_parent ≠ NULL THEN
            LET detach_op = [type: "detach_child", node: original_parent, child: op.node]
            IN ∀ s ∈ shardMap[original_parent] :
                LeaderAppend(s, detach_op)
        \* Attach to new parent in target shard (atomic with move)
        ∧ IF op.new_parent ≠ NULL THEN
            LET attach_op = [type: "attach_child", node: op.new_parent, 
                            child: op.node, position: op.position]
            IN LeaderAppend(op.new_shard, attach_op)
        \* Preserve structure if no new parent (make root)
        ∧ IF op.new_parent = NULL THEN
            LeaderAppend(op.new_shard, [type: "create_root", new_node: op.node])
        \* Cleanup old shard references
        ∧ ∀ s ∈ old_shards :
            LeaderAppend(s, [type: "shard_remove", node: op.node])
        ∧ UNCHANGED <<sceneState>>  \* State transfers handle structure

(*-------------------------- Crash Recovery --------------------------*)
RecoverNode(n) ==
    ∧ n ∈ crashed
    ∧ appliedIndex' = [appliedIndex EXCEPT ![n] = 0]
    ∧ WHILE appliedIndex[n] < shardCommitIndex[n] DO
        LET entry = shardLogs[shard][appliedIndex[n] + 1]
        IN  CASE entry.cmd.type = "state_transfer" →
                sceneState' = [sceneState EXCEPT ![entry.cmd.node] = entry.cmd.state]
            [] OTHER →
                IF entry.shard ∈ shardMap[n] THEN ApplySceneOp(entry.cmd) ELSE UNCHANGED
        ∧ appliedIndex' = [appliedIndex EXCEPT ![n] = appliedIndex[n] + 1]
    ∧ crashed' = crashed ∖ {n}

(*-------------------------- Parallel Commit Protocol -----------------------*)
StartParallelCommit(txn) ==
    LET coordShard == CHOOSE s ∈ txn.shards : TRUE
    LET txnEntry == [txn EXCEPT !.status = "COMMITTING", !.coordShard = coordShard]
    IN
    ∧ pendingTxns' = [pendingTxns EXCEPT ![txn.txnId] = txnEntry]
    ∧ ∀ s ∈ txn.shards : 
        IF s = coordShard
        THEN LeaderAppend(s, txnEntry)
        ELSE LeaderAppend(s, [type: "COMMIT", txnId: txn.txnId, hlc: txn.hlc])

CheckParallelCommit(txnId) ==
    LET txn == pendingTxns[txnId]
    LET committedInShard(s) ==
        ∃ idx ∈ 1..Len(shardLogs[s]) : 
            ∧ shardLogs[s][idx].cmd.txnId = txnId
            ∧ idx ≤ shardCommitIndex[s]
    IN
    IF ∀ s ∈ txn.shards : committedInShard(s)
    THEN ∧ pendingTxns' = [pendingTxns EXCEPT ![txnId].status = "COMMITTED"]
         ∧ ApplyTxnOps(txn.ops)
    ELSE IF pc[self] - txn.hlc > MaxLatency
    THEN AbortTxn(txnId)

(*---------------------- Transaction Handling -----------------------*)
CheckConflicts(txn) ==
    LET committedOps == UNION { {entry.cmd} : s ∈ Shards, entry ∈ shardLogs[s][1..shardCommitIndex[s]] }
    IN
    ∀ op ∈ txn.ops:
        ∀ entry ∈ committedOps:
            CASE entry.type = "COMMIT" :
                ∃ op2 ∈ pendingTxns[entry.txnId].ops : 
                    Conflict(op, op2) ∧ entry.hlc < txn.hlc
            [] OTHER :
                Conflict(op, entry) ∧ entry.hlc < txn.hlc
            ⇒ AbortTxn(txn.txnId)
    ∧ ∀ s ∈ txn.shards :
        preparedHLCs[s] = Append(preparedHLCs[s], txn.hlc)

Conflict(op1, op2) ==
    ∨ (op1.node = op2.node ∧ (IsWrite(op1) ∧ IsWrite(op2)) 
       ∧ (op1.key = op2.key ∨ op1.type ∉ {"set_property", "remove_property"}))
    ∨ (op1.type = "create_root" ∧ op2.type = "create_root" ∧ op1.new_node = op2.new_node)
    ∨ (IsTreeMod(op1) ∧ (op2.node ∈ Descendants(op1.node) ∨ op1.node ∈ Descendants(op2.node)))
    ∨ (IsTreeMod(op2) ∧ (op1.node ∈ Descendants(op2.node) ∨ op2.node ∈ Descendants(op1.node)))
    ∨ (op1.type = "move_child" ∧ op2.type = "move_child" 
       ∧ op1.parent = op2.parent ∧ op1.child_node = op2.child_node)
    ∨ (op1.type = "move_child" ∧ op2.type ∈ {"add_child", "add_sibling"} 
       ∧ op1.parent = op2.target)

IsWrite(op) == op.type ∈ {"set_property", "remove_property"}
IsTreeMod(op) == op.type ∈ {"reparent_subtree", "remove_node", "remove_subtree", "create_root", "move_child"}

(*-------------------------- Safety Invariants ----------------------------*)
Linearizability ==
    ∀ s1, s2 ∈ Shards:
        ∀ i ∈ 1..Len(shardLogs[s1]):
            ∀ j ∈ 1..Len(shardLogs[s2]):
                shardLogs[s1][i].hlc < shardLogs[s2][j].hlc ⇒ 
                    ¬∃ op1 ∈ shardLogs[s1][i].cmd, op2 ∈ shardLogs[s2][j].cmd : 
                        Conflict(op1, op2)

NoOrphanNodes ==
    LET Roots == { n ∈ DOMAIN sceneState : 
                     ∀ m ∈ DOMAIN sceneState : 
                         n ≠ sceneState[m].left_child ∧ n ≠ sceneState[m].right_sibling } IN
    LET R(m, n) == n = sceneState[m].left_child ∨ n = sceneState[m].right_sibling IN
    LET Reachable == { n ∈ DOMAIN sceneState : 
                         ∃ path ∈ Seq(DOMAIN sceneState) : 
                             ∧ Head(path) ∈ Roots 
                             ∧ ∀ i ∈ 1..Len(path)-1 : R(path[i], path[i+1]) } IN
    DOMAIN sceneState ⊆ Reachable

TransactionAtomicity ==
    ∀ txn ∈ pendingTxns:
        txn.status = "COMMITTED" ⇒ 
            ∀ s ∈ txn.shards :
                ∃! entry ∈ shardLogs[s] : entry.cmd.txnId = txn.txnId
            ∀ op ∈ txn.ops:
                CASE op.type ∈ {"add_child", "add_sibling", "create_root"} →
                    op.new_node ∈ DOMAIN sceneState
                [] op.type = "remove_node" ∨ op.type = "remove_subtree" →
                    op.node ∉ DOMAIN sceneState
                [] OTHER → TRUE
        txn.status = "ABORTED" ⇒ 
            ∀ op ∈ txn.ops:
                CASE op.type ∈ {"add_child", "add_sibling", "create_root"} →
                    op.new_node ∉ DOMAIN sceneState
                [] OTHER → TRUE

NoDanglingIntents ==
    ∀ txn ∈ DOMAIN pendingTxns:
        pendingTxns[txn].status = "COMMITTED" ⇒ 
            ∀ s ∈ pendingTxns[txn].shards:
                ∃! entry ∈ shardLogs[s] : entry.cmd.txnId = txn

CrossShardAtomicity ==
    ∀ t1, t2 ∈ pendingTxns :
        t1 ≠ t2 ∧ t1.status ≠ "ABORTED" ∧ t2.status ≠ "ABORTED"
        ∧ ∃ s ∈ t1.shards ∩ t2.shards
        ⇒ ¬∃ op1 ∈ t1.ops, op2 ∈ t2.ops : Conflict(op1, op2)
    ∀ t1, t2 ∈ pendingTxns:
        t1 ≠ t2 ∧ ∃ node: shardMap[node] ∈ t1.shards ∩ t2.shards
        ⇒ ¬∃ op1 ∈ t1.ops, op2 ∈ t2.ops: Conflict(op1, op2)

NoPartialBatches ==
    ∀ entry ∈ UNION {shardLogs[s] : s ∈ Shards} :
        entry.cmd.type = "batch_update" ⇒
            ∀ update ∈ entry.cmd.updates :
                ∃! e ∈ UNION {shardLogs[s] : s ∈ Shards} : e.hlc = entry.hlc ∧ e.cmd.node = update.node

PropertyTombstoneConsistency ==  
    ∀ n ∈ DOMAIN sceneState :
        ∀ k ∈ DOMAIN sceneState[n].properties :
            ∃! e ∈ UNION {shardLogs[s] : s ∈ Shards} : 
                e.cmd.node = n ∧ 
                e.cmd.key = k ∧ 
                (e.cmd.type = "set_property" ∨ e.cmd.type = "remove_property")

SiblingOrderConsistency ==
    ∀ p ∈ DOMAIN sceneState:
        LET children == OrderedChildren(p) IN
        ∀ i ∈ 1..Len(children)-1:
            sceneState[children[i]].right_sibling = children[i+1]            
ParallelCommitConsistency ==
    ∀ txn ∈ pendingTxns : txn.status = "COMMITTED" ⇒ ∀ s ∈ txn.shards : ∃! e ∈ shardLogs[s] : e.cmd.txnId = txn.txnId
