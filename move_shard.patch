--- a/GodotSync.tla
+++ b/GodotSync.tla
@@ -235,25 +235,35 @@
             LET new_order == SubSeq(filtered, 1, adj_idx) ◦ <<c>> ◦ SubSeq(filtered, adj_idx+1, Len(filtered))
             IN
             sceneState' = RebuildSiblingLinks(p, new_order)
-    \* Critical Fix: Move entire subtree to prevent orphans (CVE-2023-32761)
+    \* Atomic subtree migration with parent reattachment
     [] op.type = "move_shard" →
         LET old_shards = shardMap[op.node]
             descendants = Descendants(op.node)  \* Get full subtree
+            original_parent = CHOOSE p ∈ DOMAIN sceneState : 
+                                 sceneState[p].left_child = op.node ∨ 
+                                 sceneState[p].right_sibling = op.node
         IN ∧ ∀ n ∈ descendants :
                 ∧ LeaderAppend(op.new_shard, [type: "state_transfer", node: n, 
                                            state: sceneState[n], hlc: HLC])
-                ∧ IF Cardinality(Server) = 1 
-                    THEN shardMap' = [shardMap EXCEPT ![n] = @ ∪ {op.new_shard}]
-                    ELSE ∧ shardMap' = [shardMap EXCEPT ![n] = {op.new_shard}]
-                        ∧ LeaderAppend(op.new_shard, [type: "shard_leave", node: n, 
-                                                    old_shard: shardMap[n]])
+                ∧ shardMap' = [shardMap EXCEPT ![n] = {op.new_shard}]
                 ∧ ∀ s ∈ old_shards : 
                     LeaderAppend(s, [type: "shard_remove", node: n])
-        ∧ IF Cardinality(Server) > 1 
-            THEN ∀ s ∈ shardMap[op.node] :
-                    LeaderAppend(s, [type: "shard_remove", node: op.node])
-            ELSE UNCHANGED shardLogs
-        ∧ UNCHANGED <<sceneState>>  \* Structural changes handled via state transfer
+        \* Detach from original parent (cross-shard operation)
+        ∧ IF original_parent ≠ NULL THEN
+            LET detach_op = [type: "detach_child", node: original_parent, child: op.node]
+            IN ∀ s ∈ shardMap[original_parent] :
+                LeaderAppend(s, detach_op)
+        \* Attach to new parent in target shard (atomic with move)
+        ∧ IF op.new_parent ≠ NULL THEN
+            LET attach_op = [type: "attach_child", node: op.new_parent, 
+                            child: op.node, position: op.position]
+            IN LeaderAppend(op.new_shard, attach_op)
+        \* Cleanup old shard references
+        ∧ ∀ s ∈ old_shards :
+            LeaderAppend(s, [type: "shard_remove", node: op.node])
+        \* Preserve structure if no new parent (make root)
+        ∧ IF op.new_parent = NULL THEN
+            LeaderAppend(op.new_shard, [type: "create_root", new_node: op.node])
+        ∧ UNCHANGED <<sceneState>>  \* State transfers handle structure
 
 (*-------------------------- Crash Recovery --------------------------*)
 RecoverNode(n) ==
@@ -346,6 +356,8 @@
 TransactionAtomicity ==
     ∀ txn ∈ pendingTxns:
         txn.status = "COMMITTED" ⇒ 
+            ∀ s ∈ txn.shards :
+                ∃! entry ∈ shardLogs[s] : entry.cmd.txnId = txn.txnId
             ∀ op ∈ txn.ops:
                 CASE op.type ∈ {"add_child", "add_sibling", "create_root"} →
                     op.new_node ∈ DOMAIN sceneState
